# This file was *autogenerated* from the file maze_generator.sage
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
load("./block.sage")
import random

class MazeTree:
    def __init__(self,m,n,doors=_sage_const_2 ,glasses=_sage_const_0 ):
        from itertools import groupby
        self.m,self.n=m,n
        d={ self.to_index_xy(i,j): map(self.to_index,self.adjacent((i,j))) for j in range(n) for i in range(m) }
        self.G= Graph(d)
        self.spanning_tree=self.G.random_spanning_tree()
        roads = []
        for k,g in groupby(self.spanning_tree, lambda p:p[_sage_const_0 ]):
            roads.append((k,map(lambda p:p[_sage_const_1 ],list(g))))

        self.roads = roads
        self.x,self.y = map(lambda x:_sage_const_2 *x+_sage_const_1 ,(m,n))
        self.maze = [[ MazeTree.AnyBlock() if any(map(lambda x:x%_sage_const_2 ==_sage_const_0 ,(i,j))) else Road() for j in range(self.y)] for i in range(self.x)]

        for s,L in roads:
            for d in L:
                x,y = self.wall_pos_between_two_map_index(s,d)
                self.maze[x][y]=Road()

        self.add_random_glasses(glasses)
        self.add_random_doors(doors)

    @staticmethod
    def AnyBlock():
        lst=[Glass(),Wall(),Wall(),Glass(),Glass(),Glass(),Glass(),Wall(),Wall(),Wall()]
        return random.choice(lst)

    def add_door_to_maze(self,p):
        x,y=p
        self.maze[x][y]=Door()

    def add_random_doors(self,n=_sage_const_2 ):
        borders = self.borders()
        shuffle(borders)

        for k in range(n):
            self.add_door_to_maze(borders[k])
    
    def add_glass_to_maze(self,p):
        x,y=p
        self.maze[x][y]=Glass()

    def add_random_glasses(self,n=_sage_const_0 ):
        if n==_sage_const_0 :
            n=(self.x+self.y)//_sage_const_2 
        borders=self.shuffle_borders() 
        for k in range(n):
            self.add_glass_to_maze(borders[k])


    def borders(self):
        return [ (_sage_const_2 *k+_sage_const_1 ,_sage_const_0 ) for k in range(self.m)] + [ (_sage_const_2 *k+_sage_const_1 ,self.y-_sage_const_1 ) for k in range(self.m) ] + [ (_sage_const_0 ,_sage_const_2 *k+_sage_const_1 ) for k in range(self.n)] + [ (self.x-_sage_const_1 , _sage_const_2 *k+_sage_const_1 ) for k in range(self.n)]

    def shuffle_borders(self):
        borders=self.borders()
        shuffle(borders)
        return borders

    def wall_pos_between_two_map_index(self,s,d):
        md,ms=map(self.from_index,(d,s))
        dv=[md[i]-ms[i] for i in range(_sage_const_2 )] 
        direction = map(sgn,dv)
        return map(lambda (x,y):x+y,zip(self.from_map_index_to_maze_pos(s),direction))

    def from_map_index_to_maze_pos(self,k):
        m,n=self.from_index(k)
        return map(lambda x:_sage_const_2 *x+_sage_const_1 ,(m,n))

    def from_index(self,k):
        return (k%self.m,k//self.m)


    def to_index_xy(self,x,y):
        return self.to_index((x,y))

    def to_index(self,p):
        x,y=p
        return x+y*self.m

    def adjacent(self,p):
        x,y=p
        L=[(x+_sage_const_1 ,y),(x-_sage_const_1 ,y),(x,y+_sage_const_1 ),(x,y-_sage_const_1 )]
        return filter(self.valid_position,L)

    def valid_position(self,p):
        return p[_sage_const_0 ] in (ellipsis_range(_sage_const_0  ,Ellipsis, self.m-_sage_const_1 )) and p[_sage_const_1 ] in (ellipsis_range(_sage_const_0  ,Ellipsis, self.n-_sage_const_1 ))

    def __str__(self):
        return "\n".join([ "".join(map(str,k)) for k in self.maze])


def main():
    import sys
    if len(sys.argv)<_sage_const_3 :
        print "USAGE: sage tree_gen.sage rows cols [doors] [glasses]"
        return
    print MazeTree(*map(int,sys.argv[_sage_const_1 :]))

if __name__ == "__main__":
    main()
